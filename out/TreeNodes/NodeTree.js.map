{"version":3,"sources":["../src/TreeNodes/NodeTree.ts"],"names":[],"mappings":"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","file":"NodeTree.js","sourcesContent":["/* Module Imports */\r\nimport { NodeMember } from \"./Node\";\r\nimport { Vector2D, createVector } from '../Utilities/Vectors';\r\nimport { ActiveNode, Assets, Size2D, Linker } from '../Utilities/interfaces';\r\n\r\n\r\n/** Node Tree Class holds a \"Tree\" of Node Members\r\n * Has various methods to perform on EACH Node member\r\n*/\r\nexport class NodeTree {\r\n    // Private Variables\r\n    private ctx: CanvasRenderingContext2D;\r\n    private nodes: NodeMember[];\r\n    private activeNode: ActiveNode;\r\n    private relationDist: number;\r\n    private assets: Assets;\r\n\r\n    /** Default Constructor\r\n     * Initiates Canvas Context 2D and Relation Distance to Connect with other Nodes\r\n     * Requires the Image Source to be Loaded\r\n     * @param canvasContext -Canvas Rendering Context2D used to draw onto Canvas\r\n     * @param assets -An Assets object that has all the image assets required\r\n     * @param relationDistance -The required distance from the related Node in order to stay connected to\r\n    */\r\n    constructor(canvasContext: CanvasRenderingContext2D, assets: Assets, relationDistance: number) {\r\n        // Assigning Variables\r\n        this.ctx = canvasContext;\r\n        this.relationDist = relationDistance; // Required distance to another node to cause a Connection\r\n        this.nodes = [];\r\n        \r\n        // Initiate Active Node\r\n        this.resetActiveNode();  // No Nodes yet\r\n\r\n        // Assets Setup\r\n        this.assets = assets;\r\n    }\r\n\r\n    /** Adds a new Node member to Tree\r\n     * Requires an initial Location to add member to (Vector2D Style)\r\n     * Requires a size (Size2D Style)\r\n    */\r\n    public addNode(loc: Vector2D, size: Size2D): void {\r\n        let pos: Vector2D = createVector(loc.x, loc.y);\r\n\r\n        this.nodes.push( new NodeMember(this.ctx, this.assets.core, pos, size, this.relationDist) );\r\n    }\r\n\r\n    /** Removes Node based on Index Parameter \r\n     * @param index -Index of Node in array\r\n    */\r\n    public removeNode(index: number): void {\r\n        // Set security code\r\n        if(index < 0 || index >= this.nodes.length || index == undefined) return;\r\n\r\n        // Remove the node from the array\r\n        this.nodes.splice(index, 1);\r\n    }\r\n\r\n    /** Moves Node members around\r\n     * Depending on where the Mouse's Position is, is where the Node will move\r\n     * Only moves the Active Node\r\n     */\r\n    public dragNode(mousePos: Vector2D): void {\r\n        // Check if there are any active nodes\r\n        if(this.activeNode.member) {\r\n            // Make a copy of mouse Vector\r\n            let pos = mousePos.copy();\r\n            \r\n            // Calculate the change in Vector\r\n            // Get the Node Position Reference\r\n            let delta = pos.copy();\r\n            delta.sub(this.activeNode.startingPos);\r\n            let nodePos = this.activeNode.member.getPosition();\r\n\r\n            // Accumulate the Vector according to mouse's delta\r\n            nodePos.add(delta);\r\n\r\n            // Reset the starting position of the Node\r\n            this.activeNode.startingPos = pos;\r\n        }\r\n    }\r\n\r\n    /** Sets the Node that the mouse is over to Active \r\n     * Depending on where the mousePos is -> Activate a Node\r\n    */\r\n    public setActiveNode(mousePos: Vector2D): void {\r\n        for (let x = 0; x < this.nodes.length; x++) {\r\n            if (this.nodes[x].onNode(mousePos.copy())) {\r\n                this.activeNode.member = this.nodes[x];                 // Assign the Active Member based on Mouse Location\r\n                this.activeNode.index = x;                              // Keep track of the index node is in\r\n                this.activeNode.startingPos = mousePos.copy();          // Starting Mouse Position\r\n                this.activeNode.member.setHighlight(true);              // Turn on Hightlight\r\n                return;\r\n            }\r\n        }\r\n\r\n        this.resetActiveNode(); // If non found -> Nullify Active\r\n    }\r\n\r\n    /** Sets the active Linker of current Node \r\n     * @param linker -Linker that will be set to the current active node\r\n    */\r\n    public setActiveLinker(linker: Linker): void {\r\n        this.activeNode.linker = linker;\r\n    }\r\n\r\n    /** Draws and Updates each Node Member */\r\n    public run(): void {\r\n        for(const node of this.nodes) node.update();        // Update First (Because of linkers underneath the node)\r\n        for(const node of this.nodes) node.draw();          // Then Draw\r\n        \r\n\r\n        // Display Properties of Active Node\r\n        if (this.activeNode.member) {\r\n            this.activeNode.member.drawLinkers();\r\n        }\r\n\r\n        // Organize Active Node\r\n        if(this.activeNode.member){\r\n            this.organizeNode(this.activeNode.member);\r\n        }\r\n    }\r\n\r\n    /** Organizes Nodes Based on Parents to Children \r\n     * @param parent The Member that will be organized\r\n    */\r\n    public organizeNode(parent: NodeMember): void {\r\n        // For Performace, Make sure parent has children before\r\n        // creating any variables\r\n        if(!parent.hasChildren()) return;\r\n\r\n        // Variables\r\n        let space       = parent.getSize().width;   // Space between each node\r\n        let children    = parent.getChildren();     // Parent's Children\r\n        let parentPos   = parent.getPosition();     // Parent's Vector2D Position\r\n\r\n        // Calculation Offset Value\r\n        // Offset is based on the number of GrandChildren\r\n        let offsetValue = 0;                        // Offset Value of spaces between nodes\r\n\r\n        for(const child of children){\r\n            let grandChildren = child.getChildren();\r\n            offsetValue += grandChildren.length;\r\n        }\r\n\r\n        offsetValue *= 0.8;     // Offset Value \r\n\r\n\r\n        // X-Offset\r\n        let Xoffset     = space * offsetValue;      // Overall Offset Variable\r\n\r\n        // Y-Offset\r\n        let Yoffset     = 1.2;\r\n\r\n        // Get a Midpoint for the Children\r\n        let midpoint = children.length / 2;         // Middle point of Children's Length\r\n\r\n        // Calculate the starting Point X\r\n        let x = parentPos.x - (Xoffset * Math.floor(midpoint));     // Offset of Parent's Position\r\n        x -= (space * Math.floor(midpoint));                        // Apply the Spacing of Nodes\r\n\r\n        // Calculate the starting Point Y\r\n        let y = parentPos.y + (space * Yoffset);    // Y position of each Child Node from Parent\r\n\r\n        // Create the Starting Point\r\n        let pos = createVector(x, y);\r\n\r\n        // Offset If Children Number is Even (Keeps the Nodes more Center)\r\n        if(!(children.length % 2)){\r\n            pos.x += (space + Xoffset) / 2;\r\n        }\r\n\r\n        // Set Children's New Positions\r\n        for(let x=0; x<children.length; x++){\r\n            // Set Position\r\n            children[x].setPosition(pos);\r\n\r\n            // Go to next Position\r\n            pos = pos.copy();\r\n            pos.x += space + Xoffset;\r\n        }\r\n\r\n        // Continue Organizing Down the Tree\r\n        for(const child of children)\r\n            this.organizeNode(child);\r\n    }\r\n\r\n    /** Resets the Node Members Array */\r\n    public reset(): void {\r\n        this.nodes = [];\r\n    }\r\n\r\n    /** Returns the current Active Node Object */\r\n    public activeMember(): ActiveNode {\r\n        return this.activeNode;\r\n    }\r\n\r\n    /** Resets Active Node to Default */\r\n    private resetActiveNode(): void {\r\n        // Turn off Highlight Node State\r\n        if(this.activeNode && this.activeNode.member)\r\n            this.activeNode.member.setHighlight(false);\r\n        \r\n        // Reset Active Node\r\n        this.activeNode = { \r\n            member: undefined,\r\n            index: undefined,\r\n            linker: undefined,\r\n            startingPos: undefined\r\n        };\r\n    }\r\n}\r\n\r\n"]}